---
title: "Online change-point detection by e-detectors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(EDCP)
```

```{r example}
# Gaussian case
# Pre-change : N(0,1)
# Post-change: N(mu, sig)
# Change-point: v = 0 (immediate chane), 200, 500, 1000 (no change)

max_sample <- 1000L
mu <- 1
sig <- sqrt(2)
v <- 500
alpha <- 0.1/max_sample

# Compute optimal delta star
delta_star <- mu / sig^2
# delta_star <- 2
delta_upper <- 10
delta_lower <- 0.001


# Generate sample
generator <- function(v = 100){
  x_vec <- numeric(max_sample)
  if (v > 0){
    x_vec[1:v] <- rnorm(v)
  }
  if (v < max_sample){
    x_vec[seq(v+1, max_sample)] <- rnorm(max_sample - v, mu, sig)
  }
  return(x_vec)
}
x_vec <- generator(v)
plot(1:max_sample, x_vec, pch=20, 
     xlab = "n", ylab = "X_n", main = "Simulated Data")
lines(x = c(0,v), y = c(0,0), col = 2, lwd = 2)
lines(x = c(v,max_sample), y = c(mu,mu), col = 2, lwd =2 )
```

```{r}
# When delta_lower = delta_upper = delta_star
base_param <- compute_baseline(
  alpha,
  delta_lower = delta_star,
  delta_upper = delta_star
)
g_alpha_single <- base_param$g_alpha

# Compute e-detectors
log_base_fn_list <- sapply(base_param$lambda, 
                           generate_log_base_fn,
                           psi_fn = base_param$psi_fn_list$psi)

# e-value for testing (it is not the scope of this package but good for debugging)
# log_e_val_vec <- cumsum(log_base_fn_list[[1]](x_vec))
single_e_val <- update_log_mix_e_values(x_vec,
                                        base_param$omega,
                                        log_base_fn_list)


plot(1:max_sample, single_e_val$log_mix_e_val, type = "l", 
     xlab = "n", ylab = "e-value")
abline(h = g_alpha_single, col = 2)
abline(v = v, col = 1, lty = 2)
```

```{r}
# e-detector 1. SR-type
single_SR <- update_log_mix_e_detectors(x_vec,
                                              base_param$omega,     
                                              log_base_fn_list)

# e-detector 2. CUSUM-type
single_CS <- update_log_mix_e_detectors(x_vec,
                                              base_param$omega,     
                                              log_base_fn_list,
                                              is_SR_type = FALSE)


plot(1:max_sample, single_e_val$log_mix_e_val, type = "l",
     xlim = c(0, max_sample),
     ylim = c(min(single_e_val$log_mix_e_val), max(single_SR$log_mix_e_detect_val)),
     xlab = "n", ylab = "log e-val", main = paste0("v = ", v))
abline(h = g_alpha_single, col = 2)
abline(v = v, col = 1, lty = 2)
lines(1:max_sample, single_SR$log_mix_e_detect_val, type = "l", col = 3)
lines(1:max_sample, single_CS$log_mix_e_detect_val, type = "l", col = 4)
```

```{r}
# When delta_lower < delta_star < delta_upper
base_param <- compute_baseline(
  alpha,
  delta_lower = delta_lower,
  delta_upper = delta_upper,
  k_max = 1000
)

g_alpha_mix <- base_param$g_alpha

# Compute e-detectors
log_base_fn_list <- sapply(base_param$lambda, 
                           generate_log_base_fn,
                           psi_fn = base_param$psi_fn_list$psi)

# e-value for testing (it is not the scope of this package but good for debugging)
# log_e_val_mat <- sapply(log_base_fn_list, function(f) f(x_vec))
# log_omega <- log(base_param$omega)
# log_mix_e_val_vec <-  cumsum(
#   apply(log_e_val_mat, 1, function(log_e_vec){matrixStats::logSumExp(log_e_vec + log_omega)})
# )

mix_e_val <- update_log_mix_e_values(x_vec,
                                  base_param$omega,
                                  log_base_fn_list)

plot(1:max_sample, mix_e_val$log_mix_e_val, type = "l", 
     xlab = "n", ylab = "e-value")
abline(h = g_alpha_mix, col = 2)
abline(v = v, col = 1, lty = 2)
```

```{r}
# e-detector 1. SR-type
mix_SR <- update_log_mix_e_detectors(x_vec,
                                     base_param$omega,
                                     log_base_fn_list)


# e-detector 2. CUSUM-type
mix_CS <- update_log_mix_e_detectors(x_vec,
                                     base_param$omega,
                                     log_base_fn_list,
                                     is_SR_type = FALSE)



single_SR_stop <- min(
  which(single_SR$log_mix_e_detect_val > g_alpha_single)
  )
single_CS_stop <- min(
  which(single_CS$log_mix_e_detect_val > g_alpha_single)
  )
mix_SR_stop <- min(
  which(mix_SR$log_mix_e_detect_val > g_alpha_mix)
  )
mix_CS_stop <- min(
  which(mix_CS$log_mix_e_detect_val > g_alpha_mix)
  )

# Plot all 
plot(1:max_sample, mix_e_val$log_mix_e_val, type = "l",
     xlab = "n", ylab = "log e-val", main = paste0("v = ", v),
     xlim = c(0, max_sample),
     ylim = c(min(single_e_val$log_mix_e_val),
              max(mix_SR$log_mix_e_detect_val)))
lines(1:max_sample, single_e_val$log_mix_e_val, type = "l", lty = 2)
lines(1:max_sample, mix_SR$log_mix_e_detect_val, type = "l", col = 3)
lines(1:max_sample, single_SR$log_mix_e_detect_val, type = "l", col = 3, lty =2)
lines(1:max_sample, mix_CS$log_mix_e_detect_val, type = "l", col = 4)
lines(1:max_sample, single_CS$log_mix_e_detect_val, type = "l", col = 4, lty = 2)

abline(h = g_alpha_mix, col = 2)
abline(h = g_alpha_single, col = 2, lty = 2)
abline(v = v, col = 1, lty = 2)
abline(v = mix_SR_stop, col = 3)
abline(v = single_SR_stop, col = 3, lty = 2)
abline(v = mix_CS_stop, col = 4)
abline(v = single_CS_stop, col = 4, lty = 2)

print(single_SR_stop)
print(single_CS_stop)
print(mix_SR_stop)
print(mix_CS_stop)


```
